# assembly-language-study
Toy프로세서 어셈블리어로 별 찍기 프로그램을 만들어 봤습니다.
## 이전
![before](https://github.com/anseonghyeon/assembly-language-study/assets/62938167/47f6437b-70c8-4573-9d93-249f30515209)
## 이후
![after](https://github.com/anseonghyeon/assembly-language-study/assets/62938167/fe43e412-5313-41ef-9c97-f023fe68e2d3)
## 출력결과
![result2](https://github.com/anseonghyeon/assembly-language-study/assets/62938167/fa41f643-71fa-4990-9375-e5d52918f8cc)

프로그램 개요 설명
보통 어떠한 프로그래밍 언어의 반복문을 배우고 나면 처음으로 해보는 것이 별 찍기인데 이것을 어셈블리어로도 해보면 재밌을 것 같아서 만들어 보았습니다.
프로그램 내용 및 설명(.s 파일)
사용자의 입력 값을 높이로 하는 삼각형을 출력하는 어셈블리어 프로그램입니다. 입력은 1부터 9까지의 수만 가능합니다. 
.ORIGIN 0x2000; 프로그램 시작주소를 0x2000번지로 설정합니다.
COPY R0, 0; 다음 라인에서 에코모드를 끄기 위해서 R0 레지스터의 값을 0으로 저장합니다.
SWI 4; R0 레지스터의 값으로 에코모드를 설정합니다.
SWI 0; 사용자가 키보드로 입력한 값을 읽어 옵니다.

COPY R1, R0; 입력된 문자를 R1 레지스터로 옴겨둡니다. 이유는 R0 레지스터는 이후 입출력에 사용해야 할 레지스터이기 때문입니다.
SUB R1, R1, 48; 입력된 값은 문자이기 때문에 반복문의 카운터로 사용하기 위해서는 정수로 변환해주어야 합니다. 그래서 아스키 코드표를 참고해서 정수 48을 빼 주었습니다.
COPY R3, R1; 삼각형의 높이를 입력된 값으로 초기화 해줍니다.
outer_loop: COPY R2, R1; 한 행마다 별을 출력할 수 있는 최대 횟수를 초기화 해줍니다. 
inner_loop: COPY R0, ‘*’; 별 모양을 출력하기 위해 R0 레지스터에 ‘*’를 저장합니다.
SW 1; R0 레지스터에 저장된 값을 출력합니다.
SUB R2, R2, 1; 별모양의 출력 횟수를 제한하기 위해 R2의 값을 1 감소시켜줍니다.
CMP R2, R3; R2 레지스터의 값과 R3 레지스터의 값을 비교합니다.
BR zp, inner_loop; 이전의 산술 연산에서 R3 레지스터의 값이 더 작거나 같아서 연산 결과가 양수나 0이 되었다면 inner_loop라벨로 분기하여 다시 별 모양을 출력하고 R2 레지스터의 값이 더 작아서 연산 결과가 음수가 되었다면 다음 명령어를 처리하러 넘어갑니다.
COPY R0, 10; 다음 행에 별을 찍기위해 개행문자를 뜻하는 10을 R0 레지스터에 저장합니다. 
SWI 1; R0 레지스터에 저장된 값을 출력함으로서 개행문자를 출력합니다. 
SUB R3, R3, 1; 개행을 했다면 삼각형의 높이를 제한하기 위해 R3 레지스터의 값을 1 감소시킵니다.
CMP R3, 0; R3 레지스터의 값과 0을 비교합니다.
BR p, outer_loop; 이전의 산술 연산에서 R3 레지스터의 값이 0보다 여전히 크다면 다음 행에 별을 찍으로 outer_loop라벨로 분기하고 연산 결과가 0이라면 사용자가 입력한 값만큼의 높이를 가진 삼각형을 찍은 것 이기 때문에 루프에서 탈출하고 다음 명령어를 처리하러 넘어갑니다.
SWI 255; 마지막으로 운영체제의 기능을 호출함으로서 프로그램을 종료 합니다. 
어셈블러 출력 및 설명(.lst 파일)
 
프로그램의 시작은 0x002000번지부터 시작하고 프로그램의 종료는 0x002011번지의 명령어로 종료됩니다. 심볼 테이블(label)에 outer_loop는 0x002006번지를 의미하고 inner_loop는 0x002006번지를 의미합니다. 나머지 명령어에 대한 해석은 프로그램 명령 및 설명 챕터와 같습니다.
기계어 프로그램 간단한 설명(시뮬레이터 실행 시작 화면 캡쳐)
 
프로그램 이름은 star이고 레지스터는 R0, R1, R2, R3 레지스터를 사용하였습니다. 아직 첫번째 명령어를 읽어오지 않았기 때문에 IR에는 0이 저장 되어있습니다. PC에는 다음에 읽어와야 하는 첫번째 명령어의 주소가 저장 되어있습니다. CCR의 모든 비트는 0으로 설정되어 있습니다.   
프로그램 실행 과정 및 설명(시뮬레이터 실행 주요화면 캡쳐)
제가 생각하는 이 프로그램의 주요 부분은 문자를 숫자로 변환하는 부분과 반복문으로 별을 출력하는 부분이라고 생각합니다. 그중에서 입력된 문자를 숫자로 변환하는 부분을 설명하겠습니다.
 
현재 캡쳐된 화면의 상황은 3번째 라인에서 사용자가 입력한 문자를 읽어와서 4번째 라인에서 그 값을 R1 레지스터로 옴겨둔 상황입니다. 이때 사진과 같이 5번째 라인의 명령어를 실행해서 문자 ‘9’의 아스키 코드값 57에 48을 빼서 제가 원하는 정수 9를 얻어내는 실행 과정입니다. 
 
위의 5번째 라인의 명령어가 실행된 후 R1 레지스터의 값을 보시면 문자’9’를 뜻하는 아스키코드 57에서 정수9가 된 것을 볼 수 있습니다.
실행결과 검증
입력 값이 5일 때 5층 높이의 삼각형을 출력합니다.
 
입력 값이 9일 때 9층 높이의 삼각형을 출력합니다.
 
요약 및 결론
어셈블리언어로 프로그래밍을 해본 결과 간단한 프로그램을 작성하는 것도 복잡해서 선조들의 고급언어 발명에 감사함을 느꼈습니다.
![image](https://github.com/user-attachments/assets/36fc5ed0-ac70-4f1b-a2ac-82706a557ed2)
